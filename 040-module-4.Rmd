# Module 4: Finding Differentially Expressed Genes From RNAseq Data

## Lecture

<iframe width="640" height="360" src="https://www.youtube.com/embed/dFAORze0FTc?si=mmhUEbRzkVkL3zEZ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<br>

![Module 4: Finding Differentially Expressed Genes From RNAseq Data Slides](content-files/module-4-lecture.pdf){width=100% height=900}\

## Lab

In this exercise, we will use `edgeR` to call differentially-expressed genes. For the example we will use an RNAseq dataset from a treatment-vehicle design.

If you haven’t already done so, install the `airway` dataset:
```{r, message=FALSE}
# BiocManager::install("airway") 
```

These data are from the paper:

Himes BE, Jiang X, Wagner P, Hu R, Wang Q, Klanderman B, Whitaker RM, Duan Q, Lasky-Su J, Nikolos C, Jester W, Johnson M, Panettieri R Jr, Tantisira KG, Weiss ST, Lu Q. “RNA-Seq Transcriptome Profiling Identifies CRISPLD2 as a Glucocorticoid Responsive Gene that Modulates Cytokine Function in Airway Smooth Muscle Cells.” PLoS One. 2014 Jun 13;9(6):e99625. PMID: [24926665](https://pubmed.ncbi.nlm.nih.gov/24926665/).

From the abstract of the original paper: “Using RNA-Seq, a high-throughput sequencing method, we characterized transcriptomic changes in four primary human ASM cell lines that were treated with dexamethasone - a potent synthetic glucocorticoid (1 micromolar for 18 hours).”

Let’s load the data:
```{r}
suppressMessages(library(airway))
data(airway)
```

These data happen to be in a Bioconductor-specific format, so we use the special functions, `assay()` and `colData()` to get the expression data and sample information.
```{r, message=FALSE}
xpr <- assay(airway)
samples <- colData(airway)
```

**Questions:**

* How many samples are in this experiment?
* How many genes were measured?
* How many treatment groups are there (`dex` column)?

Let’s created a `DGEList` object (DGE stands for “Differential Gene Expression”). This object is what we will use for our differential expression analysis.

Note: Make phenotype of interest categorical. In R that means converting to a `factor` type with categorical levels. You can think of `levels` as ordinal representations (e.g., first level = 1, second = 2, etc., )

If `levels=` are not set, the default uses alphabetical order. We recommend explicitly setting levels so that there are no assumptions.

Load the edgeR package:
```{r}
suppressMessages(library(edgeR))
```

Let’s create a `DGEList` object for the differential expression analysis. Note that group must be a categorical variable (use `factor()` to convert it to one):
```{r, message=FALSE}
group <- factor(samples$dex)
dge <- DGEList(
    counts = xpr,
    group = group
    )
```

Remove low-count genes: To filter low count genes, we’re going to use a normalized count measure called `cpm` (counts per million). We are going to keep genes with 100 or greater counts per million for at least two samples:
```{r, message=FALSE}
head(dge$counts)
```

Look at counts per million using `cpm`:
```{r, message=FALSE}
cpm(dge)[1:5,1:5]
```

This next line is a bit complex so let’s unpack it:

We are using `cpm(dge)>100` as a logical test (“which genes have cpm > 100?”).
For each gene, we want that test to be true for at least two samples. For this we use `rowSums()` to add up how many samples meet that criteria.
```{r, message=FALSE}
dim(dge) #before 
```

```{r, message=FALSE}
# keep genes which have cpm>100 in 2 or more samples
tokeep <- rowSums(cpm(dge)>100) >= 2 

# now filter for these
dge <- dge[tokeep,keep.lib.sizes = FALSE]

# how many genes do we have left?
dim(dge) #after
```

Normalize the data:
```{r, message=FALSE}
dge <- calcNormFactors(dge)
```

Visualize the data:
```{r, message=FALSE}
plotMDS(
    dge, 
    col=as.numeric(dge$samples$group), 
    pch=16
)
legend(
    "bottomleft", 
    as.character(unique(dge$samples$group)),
    col=c(1,2), pch=16
    )
```

Let’s create a model design to identify genes with a `group` effect:
```{r, message=FALSE}
group <- dge$samples$group
mod <- model.matrix(~group)
```

Estimate variation (“dispersion”) for each gene:
```{r, message=FALSE}
dge <- estimateDisp(dge, mod)
```

Call differentially expressed genes.

Here we:

* Fit a model for each gene, using `glmFit`
* We have built in an estimate of gene-wise dispersion to better identify treatment effect (or “contrast”)
* For each gene, we run a likelihood ratio test which compares which model fits the data better: a null model (treatment effect = 0) or a full model (treatment effect is non-zero)

Note that `coef=2` fetches the effects for the treatment effect; `coef=1` would fetch effects of the intercept term.

![Coef number](img/img-1.png)

```{r, message=FALSE}
fit <- glmFit(dge,mod)
diffEx <- glmLRT(fit, coef = 2) # get coefficients for group term
```

Look at the top 10 differentially expressed genes:
```{r, message=FALSE}
tt <- topTags(diffEx, n=10)
tt
```

For the next steps we’re going to need stats on all the genes we’ve tested. So let’s get those:
```{r, message=FALSE}
tt <- as.data.frame(
    topTags(diffEx, n=nrow(dge)
    )
)
```

A QQplot directly compares the pvalues from our statistical tests to the expected values from a random uniform distribution (p-value selected at random).

A deviation from the x=y line (diagonal) towards the top indicates an enrichment of signal.
```{r, message=FALSE}
qqplot(
    tt$PValue, 
    runif(nrow(tt)), # randomly sample from uniform distribution
    xlab="p-values from real data",
    ylab="Randomly-sampled values from Uniform distribution",
    pch=16,cex=0.5
)

# x=y line as reference
abline(0,1,col="red")
```

Now let’s call differentially expressed genes using the `decideTests()` function and use `summary()` to see how many genes are upregulated (value `+1`), downregulated (value `-1`) and not called as changed (value `0`)

```{r, message=FALSE}
diffEx2 <- decideTests(diffEx, 
    adjust.method="BH", 
    p.value=0.05
)
summary(diffEx2)
```

### Volcano Plot (R base graphics)

A **volcano plot** can help visualize effect magnitude - log2 fold-change or `log2FC` in the table ` against the corresponding p-value. Here we create a volcano plot, and colour-code upregulated genes in red, and downregulated genes in blue.

Let’s merge the data from `tt` and `diffEx2` (which has the up-/down-regulated status):
```{r, message=FALSE}
# needed to use merge function
diffEx2 <- as.data.frame(diffEx2) 
# give column more intuitive name
colnames(diffEx2)[1] <- "gene_status"

# add the common "gene" column to merge the two tables
diffEx2$gene <- rownames(diffEx2)
tt$gene <- rownames(tt)

mega <- merge(x = tt, y = diffEx2, by="gene")
```

Now we create a vector of colours, so that our upregulated genes are in red, downregulated genes are in blue, and not-significant genes are in black:
```{r, message=FALSE}
cols <- rep("black",nrow(tt))
cols[which(mega$gene_status > 0)] <- "red" # upregulated
cols[which(mega$gene_status < 0)] <- "blue" # downregulated
mega$cols <- cols

# volcano plot
plot(mega$logFC,
    -log10(mega$PValue),
    pch=16, 
    col=mega$cols,
    xlab="log(fold-change)",
    ylab="-log10(p-value)"
)
abline(v=0,lty=3)
```

### Volcano Plot (ggplot2)

Let’s create a volcano plot using the `ggplot2` library.

For this let’s add a NEW column indicating whether a gene is up-regulated, down-regulated, or n.s.
```{r, message=FALSE}
is_sig <- rep("n.s.", nrow(mega)) # default is ns
is_sig[which(mega$gene_status > 0)] <- "Upregulated"
is_sig[which(mega$gene_status < 0)] <- "Downregulated"

# use levels() to tell R how to order the categorical 
# variables. Downregulated = 1, n.s.=2, and Upregulated=3. 
# By default, R orders categorical variables alphabetically,
# which may not make sense!
mega$is_sig <- factor(is_sig, 
    levels = c("Downregulated","n.s.","Upregulated"))
```

Now let’s create a volcano plot, colouring the dots by significance status.

We will use `scale_color_manual()` from the `ggplot2` package to add a custom colour scheme.
```{r, message=FALSE}
p1 <- ggplot(mega, 
    aes(x = logFC, y = -log10(FDR))) + # -log10 conversion  
    geom_point(aes(color=is_sig),size = 2/5) +  
    xlab(expression("log"[2]*"FC")) + 
    ylab(expression("-log"[10]*"FDR")) + 
    scale_color_manual(
        values = c("dodgerblue3", "gray50", "firebrick3")) 

p1
```

Finally we can write our differential expression results out to file:
```{r, message=FALSE}
write.table(mega,
    file="diffEx.results.txt",
    sep="\t",
    col=TRUE,
    row=TRUE,
    quote=FALSE
)
```

### Bonus Exercise

* Install the `yeastRNASeq` package from Bioconductor and `library` it into your environment
* Import the geneLevelData using: `data("geneLevelData")`
* Learn about this data and then put it through the same workflow we just did for the breast cancer: 
1. Create a new `DGEList` object with your gene counts
2. Filter genes with CPM > 25 in at least two samples
3. Normalize and plot your data
4. Create a model matrix for analysis
5. Fit your model 
6. How many significantly up-regulated genes are there at the 5% FDR level? How many significantly down-regulated genes? How many in total
7. Create a volcano plot
8. Bonus: Create a histogram of p-values. Is there a signal?

Is there anything about the data that might make you question the results?

### Bonus Exercise Results

```{r}
if (!requireNamespace("yeastRNASeq", quietly = TRUE)) 
  BiocManager::install("yeastRNASeq")

if (!requireNamespace("edgeR", quietly = TRUE)) 
  BiocManager::install("edgeR")

suppressMessages(library(yeastRNASeq))
suppressMessages(library(edgeR))

data(geneLevelData)

# only keep genes with cpm > 25 in more than two samples

# table of TRUE/FALSE values
genes_passing_cutoff <- cpm(geneLevelData) > 25 

# For each gene, add up how many samples it is TRUE in (rowSums())
# Then only keep those strictly greater than 2.
genes_keep <- rowSums(genes_passing_cutoff) > 2

# Finally subset the data
filtered <- geneLevelData[genes_keep,]

# How many genes pass this threshold?
str(filtered)
```

```{r, message=FALSE}
#  as.matrix(filtered): the count data in the right class
# phenoData: The sample information

group <- factor(rep(c("Mut", "WT"),each=2), 
    levels = c("WT","Mut")) # we tell R to use "WT" as the reference
y <- DGEList(as.matrix(filtered),
           group = group)  

## matrix of experimental design 
mod = model.matrix(~group, y)


## Normalize data
y <- calcNormFactors(y, method = "upperquartile")
y <- estimateDisp(y, mod)

fit = glmFit(y, mod)
lrt = glmLRT(fit, coef = 2)
diffEx2 <- decideTests(lrt, 
    adjust.method="BH", 
    p.value=0.05
)
table(diffEx2)
```

```{r, message=FALSE}
DEGS = topTags(lrt, n=nrow(y))$table
```

```{r, message=FALSE}
## check out differentially expressed genes
head(DEGS)
```

```{r, message=FALSE}
DEGS_sig = DEGS[DEGS$FDR < 0.05,]
head(DEGS_sig)
```

```{r, message=FALSE}
dim(DEGS_sig)
```

Now merge the `DEG` and table with the table with the table that has the up/downregulated status:
```{r, message=FALSE}
# needed to use merge function
diffEx2 <- as.data.frame(diffEx2) 
# give column more intuitive name
colnames(diffEx2)[1] <- "gene_status"

# add the common "gene" column to merge the two tables
diffEx2$gene <- rownames(diffEx2)
DEGS$gene <- rownames(DEGS)

mega <- merge(x = DEGS, y = diffEx2, by="gene")
```

Assign the column name for gene status:
```{r, message=FALSE}
is_sig <- rep("n.s.", nrow(mega)) # default is ns
is_sig[which(mega$gene_status > 0)] <- "Upregulated"
is_sig[which(mega$gene_status < 0)] <- "Downregulated"

# use levels() to tell R how to order the categorical 
# variables. Downregulated = 1, n.s.=2, and Upregulated=3. 
# By default, R orders categorical variables alphabetically,
# which may not make sense!
mega$is_sig <- factor(is_sig,
    levels = c("Downregulated","n.s.","Upregulated"))
```

Finally create the volcano plot:
```{r, message=FALSE}
p1 <- ggplot(mega, 
    aes(x = logFC, y = -log10(FDR))) + # -log10 conversion  
    geom_point(aes(color=is_sig),size = 2/5) +  
    xlab(expression("log"[2]*"FC")) + 
    ylab(expression("-log"[10]*"FDR")) + 
    scale_color_manual(
        values = c("dodgerblue3", "gray50", "firebrick3")) 

p1
```
